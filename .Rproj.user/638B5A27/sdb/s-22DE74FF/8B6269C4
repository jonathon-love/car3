{
    "collab_server" : "",
    "contents" : "#---------------------------------------------------------------------------------------\n# Revision history:\n#   2009-01-16: replaced unlist(options(\"foo\")) with getOption(\"foo\")\n#   2009-09-16: optionally allow models with aliased coefficients. J. Fox\n#   2009-12-10: modification by A. Zeileis to allow wider range of coef. names.\n#   2009-12-22: small changes to linearHypothesis.mlm() to handle user-specified\n#               within-subjects designs in Anova()\n#   2010-05-21: linearHypothesis.default() and .lm() changed so that differences\n#               in df, etc. will be postive.\n#   2010-06-12: linearHypothesis.mlm() changed to allow observation weights\n#\t2010-06-22: fixed bug in linearHypothesis.lm caused by 2010-05-21 revision\n#   2010-01-21: added methods for mixed models; added matchCoefs() and methods. J. Fox\n#   2011-05-03: fixed bug in displaying numbers starting with \"-1\" or \"+1\" in printed representation. J. Fox\n#   2011-06-09: added matchCoefs.mlm(). J. Fox\n#   2011-11-27: added linearHypothesis.svyglm(). John\n#   2011-12-27: fixed printing bug in linearHypothesis(). John\n#   2012-02-28: added F-test to linearHypothesis.mer(). John\n#   2012-03-07: singular.ok argument added to linearHypothesis.mlm(). J. Fox\n#   2012-08-20: Fixed p-value bug for chisq test in .mer method. John\n#   2012-09-17: updated linearHypothesis.mer for pkrtest 0.3-2. John\n#   2012-11-21: test for NULL rhs to avoid warning in R 2.16.0. John\n#   2013-01-28: hypotheses can now contain newlines and tabs\n#   2013-02-14: fixed bug in printing constants of the form 1.x*. John\n#   2013-06-20: added .merMod() method. John\n#   2013-06-22: tweaks for lme4. John\n#   2013-06-22: test argument uniformly uses \"Chisq\" rather than \"chisq\". J. Fox\n#   2013-08-19: removed calls to unexported functions in stats. J. Fox\n#   2014-08-17: added call to requireNamespace() and :: as needed (doesn't work for pbkrtest). J. Fox\n#   2014-08-18: fixed bug in linearHypothesis.survreg(). J. Fox\n#   2014-09-23: added linearHypothesis.rlm. J. Fox\n#   2014-12-18: check that residual df nonzero in Anova.lm() and Anova.default\n#               and residual SS nonzero in Anova.lm(). John\n#   2015-01-27: KRmodcomp() and methods now imported from pbkrtest. John\n#   2015-02-03: Check for NULL df before 0 df in default method. John\n#   2016-06-29: added \"value\" and \"vcov\" attributes to returned object, print vcov when verbose. John\n#----------------------------------------------------------------------------------------------------\n\nvcov.default <- function(object, ...){\n\tstop(paste(\"there is no vcov() method for models of class\",\n\t\t\t\t\tpaste(class(object), collapse=\", \")))\n}\n\nhas.intercept.matrix <- function (model, ...) {\n\t\"(Intercept)\" %in% colnames(model)\n}\n\n\nmakeHypothesis <- function(cnames, hypothesis, rhs = NULL){\n\tparseTerms <- function(terms){\n\t\tcomponent <- gsub(\"^[-\\\\ 0-9\\\\.]+\", \"\", terms)\n\t\tcomponent <- gsub(\" \", \"\", component, fixed=TRUE)\n\t\tcomponent\n\t}\n\tstripchars <- function(x) {\n\t  x <- gsub(\"\\\\n\", \" \", x)\n\t  x <- gsub(\"\\\\t\", \" \", x)\n\t\tx <- gsub(\" \", \"\", x, fixed = TRUE)\n\t\tx <- gsub(\"*\", \"\", x, fixed = TRUE)\n\t\tx <- gsub(\"-\", \"+-\", x, fixed = TRUE)\n\t\tx <- strsplit(x, \"+\", fixed = TRUE)[[1]]\n\t\tx <- x[x!=\"\"]\n\t\tx\n\t}\n\tchar2num <- function(x) {\n\t\tx[x == \"\"] <- \"1\"\n\t\tx[x == \"-\"] <- \"-1\"\n\t\tas.numeric(x)\n\t}\n\tconstants <- function(x, y) { \n\t\twith.coef <- unique(unlist(sapply(y,\n\t\t\t\t\t\t\t\tfunction(z) which(z == parseTerms(x)))))\n\t\tif (length(with.coef) > 0) x <- x[-with.coef]\n\t\tx <- if (is.null(x)) 0 else sum(as.numeric(x))\n\t\tif (any(is.na(x)))\n\t\t\tstop('The hypothesis \"', hypothesis,\n\t\t\t\t\t'\" is not well formed: contains bad coefficient/variable names.')\n\t\tx\n\t}\n\tcoefvector <- function(x, y) {\n\t\trv <- gsub(\" \", \"\", x, fixed=TRUE) ==\n\t\t\t\tparseTerms(y)\n\t\tif (!any(rv)) return(0)\n\t\tif (sum(rv) > 1) stop('The hypothesis \"', hypothesis,\n\t\t\t\t\t'\" is not well formed.')\n\t\trv <- sum(char2num(unlist(strsplit(y[rv], x, fixed=TRUE))))\n\t\tif (is.na(rv))\n\t\t\tstop('The hypothesis \"', hypothesis,\n\t\t\t\t\t'\" is not well formed: contains non-numeric coefficients.')\n\t\trv\n\t}\n\t\n\tif (!is.null(rhs)) rhs <- rep(rhs, length.out = length(hypothesis))\n\tif (length(hypothesis) > 1)\n\t\treturn(rbind(Recall(cnames, hypothesis[1], rhs[1]),\n\t\t\t\t\t\tRecall(cnames, hypothesis[-1], rhs[-1])))\n\t\n\tcnames_symb <- sapply(c(\"@\", \"#\", \"~\"), function(x) length(grep(x, cnames)) < 1)\n\t\n\tif(any(cnames_symb)) {\n\t\tcnames_symb <- head(c(\"@\", \"#\", \"~\")[cnames_symb], 1)\n\t\tcnames_symb <- paste(cnames_symb, seq_along(cnames), cnames_symb, sep = \"\")\n\t\thypothesis_symb <- hypothesis\n\t\tfor(i in order(nchar(cnames), decreasing = TRUE))\n\t\t\thypothesis_symb <- gsub(cnames[i], cnames_symb[i], hypothesis_symb, fixed = TRUE)\n\t} else {\n\t\tstop('The hypothesis \"', hypothesis,\n\t\t\t\t'\" is not well formed: contains non-standard coefficient names.')\n\t}\n\t\n\tlhs <- strsplit(hypothesis_symb, \"=\", fixed=TRUE)[[1]] \n\tif (is.null(rhs)) {\n\t\tif (length(lhs) < 2) rhs <- \"0\"\n\t\telse if (length(lhs) == 2) {\n\t\t\trhs <- lhs[2]\n\t\t\tlhs <- lhs[1]\n\t\t}\n\t\telse stop('The hypothesis \"', hypothesis,\n\t\t\t\t\t'\" is not well formed: contains more than one = sign.')\n\t}\n\telse {\n\t\tif (length(lhs) < 2) as.character(rhs)\n\t\telse stop('The hypothesis \"', hypothesis,\n\t\t\t\t\t'\" is not well formed: contains a = sign although rhs was specified.')\n\t}\n\tlhs <- stripchars(lhs)\n\trhs <- stripchars(rhs)\n\trval <- sapply(cnames_symb, coefvector, y = lhs) - sapply(cnames_symb, coefvector, y = rhs) \n\trval <- c(rval, constants(rhs, cnames_symb) - constants(lhs, cnames_symb)) \n\tnames(rval) <- c(cnames, \"*rhs*\")\n\trval\n}\n\nprintHypothesis <- function(L, rhs, cnames){\n\thyp <- rep(\"\", nrow(L))\n\tfor (i in 1:nrow(L)){\n\t\tsel <- L[i,] != 0\n\t\th <- L[i, sel]\n\t\th <- ifelse(h < 0, as.character(h), paste(\"+\", h, sep=\"\"))\n\t\tnms <- cnames[sel]\n\t\th <- paste(h, nms)\n\t\th <- gsub(\"-\", \" - \", h)\n\t\th <- gsub(\"+\", \"  + \", h, fixed=TRUE)\n\t\th <- paste(h, collapse=\"\")\n\t\th <- gsub(\"  \", \" \", h, fixed=TRUE)\n\t\th <- sub(\"^\\\\ \\\\+\", \"\", h)\n\t\th <- sub(\"^\\\\ \", \"\", h)\n\t\th <- sub(\"^-\\\\ \", \"-\", h)\t\n\t\th <- paste(\" \", h, sep=\"\")\n\t\th <- paste(h, \"=\", rhs[i])\t\t\n\t\th <- gsub(\" 1([^[:alnum:]_.]+)[ *]*\", \"\", \n\t\t\t\tgsub(\"-1([^[:alnum:]_.]+)[ *]*\", \"-\", \n\t\t\t\t\t\tgsub(\"- +1 +\", \"-1 \", h)))\n\t\th <- sub(\"Intercept)\", \"(Intercept)\", h)\t\t\n\t\th <- gsub(\"-\", \" - \", h)\n\t\th <- gsub(\"+\", \"  + \", h, fixed=TRUE)\n\t\th <- gsub(\"  \", \" \", h, fixed=TRUE)\n\t\th <- sub(\"^ *\", \"\", h)\n\t\thyp[i] <- h\n\t}\n\thyp\n}\n\nlinearHypothesis <- function (model, ...)\n\tUseMethod(\"linearHypothesis\")\n\nlht <- function (model, ...)\n\tUseMethod(\"linearHypothesis\")\n\t\nlinearHypothesis.nlsList <- function(model,  ..., vcov., coef.){\n   vcov.nlsList <- function(object, ...) {\n       vlist <- lapply(object, vcov)\n       ng <- length(vlist)\n       nv <- dim(vlist[[1]])[1]\n       v <- matrix(0, nrow=ng*nv, ncol=ng*nv)\n       for (j in 1:ng){\n          cells <- ((j-1)*nv + 1):(j*nv)\n          v[cells, cells] <- vlist[[j]]\n        }\n      v\n      }\n   linearHypothesis.default(model, vcov.=vcov.nlsList(model), \n       coef.=unlist(lapply(model, coef)), ...)}\n\n\nlinearHypothesis.default <- function(model, hypothesis.matrix, rhs=NULL,\n\t\ttest=c(\"Chisq\", \"F\"), vcov.=NULL, singular.ok=FALSE, verbose=FALSE, \n    coef. = coef(model), ...){\n\tdf <- df.residual(model)\n\tif (is.null(df)) df <- Inf ## if no residual df available\n    if (df == 0) stop(\"residual df = 0\")\n\tV <- if (is.null(vcov.)) vcov(model)\n\t\t\telse if (is.function(vcov.)) vcov.(model) else vcov.\n\tb <- coef.\n\tif (any(aliased <- is.na(b)) && !singular.ok)\n\t\tstop(\"there are aliased coefficients in the model\")\n\tb <- b[!aliased]\n\tif (is.null(b)) stop(paste(\"there is no coef() method for models of class\",\n\t\t\t\t\t\tpaste(class(model), collapse=\", \")))\n\tif (is.character(hypothesis.matrix)) {\n\t\tL <- makeHypothesis(names(b), hypothesis.matrix, rhs)\n\t\tif (is.null(dim(L))) L <- t(L)\n\t\trhs <- L[, NCOL(L)]\n\t\tL <- L[, -NCOL(L), drop = FALSE]\n\t\trownames(L) <- hypothesis.matrix\n\t}\n\telse {\n\t\tL <- if (is.null(dim(hypothesis.matrix))) t(hypothesis.matrix)\n\t\t\t\telse hypothesis.matrix\n\t\tif (is.null(rhs)) rhs <- rep(0, nrow(L))\n\t}\n\tq <- NROW(L)\n\tvalue.hyp <- L %*% b - rhs\n\tvcov.hyp <- L %*% V %*% t(L)\n\tif (verbose){\n\t\tcat(\"\\nHypothesis matrix:\\n\")\n\t\tprint(L)\n\t\tcat(\"\\nRight-hand-side vector:\\n\")\n\t\tprint(rhs)\n\t\tcat(\"\\nEstimated linear function (hypothesis.matrix %*% coef - rhs)\\n\")\n\t\tprint(drop(value.hyp))\n\t\tcat(\"\\n\")\n\t\tif (length(vcov.hyp) == 1) cat(\"\\nEstimated variance of linear function\\n\")\n\t\telse cat(\"\\nEstimated variance/covariance matrix for linear function\\n\")\n\t\tprint(drop(vcov.hyp))\n\t\tcat(\"\\n\")\n\t}\n\tSSH <- as.vector(t(value.hyp) %*% solve(vcov.hyp) %*% value.hyp)\n\ttest <- match.arg(test)\n\tif (!(is.finite(df) && df > 0)) test <- \"Chisq\"\n\tname <- try(formula(model), silent = TRUE)\n\tif (inherits(name, \"try-error\")) name <- substitute(model)\n\ttitle <- \"Linear hypothesis test\\n\\nHypothesis:\"\n\ttopnote <- paste(\"Model 1: restricted model\",\"\\n\", \"Model 2: \", \n\t\t\tpaste(deparse(name), collapse = \"\\n\"), sep = \"\")\n\tnote <- if (is.null(vcov.)) \"\"\n\t\t\telse \"\\nNote: Coefficient covariance matrix supplied.\\n\"\n\trval <- matrix(rep(NA, 8), ncol = 4)\n\tcolnames(rval) <- c(\"Res.Df\", \"Df\", test, paste(\"Pr(>\", test, \")\", sep = \"\"))\n\trownames(rval) <- 1:2\n\trval[,1] <- c(df+q, df)\n\tif (test == \"F\") {\n\t\tf <- SSH/q\n\t\tp <- pf(f, q, df, lower.tail = FALSE)\n\t\trval[2, 2:4] <- c(q, f, p)\n\t}\n\telse {\n\t\tp <- pchisq(SSH, q, lower.tail = FALSE)\n\t\trval[2, 2:4] <- c(q, SSH, p)\n\t}\n\tif (!(is.finite(df) && df > 0)) rval <- rval[,-1]\n\tresult <- structure(as.data.frame(rval),\n\t\t\theading = c(title, printHypothesis(L, rhs, names(b)), \"\", topnote, note),\n\t\t\tclass = c(\"anova\", \"data.frame\"))\n\tattr(result, \"value\") <- value.hyp\n\tattr(result, \"vcov\") <- vcov.hyp\n\tresult\n}\n\nlinearHypothesis.glm <- function(model, ...)\n\tlinearHypothesis.default(model, ...)\n\nlinearHypothesis.lm <- function(model, hypothesis.matrix, rhs=NULL,\n\t\ttest=c(\"F\", \"Chisq\"), vcov.=NULL,\n\t\twhite.adjust=c(FALSE, TRUE, \"hc3\", \"hc0\", \"hc1\", \"hc2\", \"hc4\"),\n\t\tsingular.ok=FALSE, ...){\n    if (df.residual(model) == 0) stop(\"residual df = 0\")\n    if (deviance(model) < sqrt(.Machine$double.eps)) stop(\"residual sum of squares is 0 (within rounding error)\")\n\tif (!singular.ok && is.aliased(model))\n\t\tstop(\"there are aliased coefficients in the model.\")\n\ttest <- match.arg(test)\n\twhite.adjust <- as.character(white.adjust)\n\twhite.adjust <- match.arg(white.adjust)\n\tif (white.adjust != \"FALSE\"){\n\t\tif (white.adjust == \"TRUE\") white.adjust <- \"hc3\"\n\t\tvcov. <- hccm(model, type=white.adjust)\n\t}\n\trval <- linearHypothesis.default(model, hypothesis.matrix, rhs = rhs,\n\t\t\ttest = test, vcov. = vcov., singular.ok=singular.ok, ...)\n\tif (is.null(vcov.)) {\n\t\trval2 <- matrix(rep(NA, 4), ncol = 2)\n\t\tcolnames(rval2) <- c(\"RSS\", \"Sum of Sq\")\n\t\tSSH <- rval[2,test]\n\t\tif (test == \"F\") SSH <- SSH * abs(rval[2, \"Df\"])\n\t\tdf <- rval[2, \"Res.Df\"]\n\t\terror.SS <- deviance(model)\n\t\trval2[,1] <- c(error.SS + SSH * error.SS/df, error.SS)\n\t\trval2[2,2] <- abs(diff(rval2[,1]))\n\t\trval2 <- cbind(rval, rval2)[,c(1, 5, 2, 6, 3, 4)]\n\t\tclass(rval2) <- c(\"anova\", \"data.frame\")\n\t\tattr(rval2, \"heading\") <- attr(rval, \"heading\")\n\t\tattr(rval2, \"value\") <- attr(rval, \"value\")\n\t\tattr(rval2, \"vcov\") <- attr(rval, \"vcov\")\n\t\trval <- rval2\n\t}\n\trval\n}\n\n\ncheck.imatrix <- function(X, terms){ \n# check block orthogonality of within-subjects model matrix\n\tXX <- crossprod(X)\n\tif (missing(terms)) terms <- attr(X, \"assign\")\n\tfor (term in unique(terms)){\n\t\tsubs <- term == terms\n\t\tXX[subs, subs] <- 0\n\t}\n\tif (any(abs(XX) > sqrt(.Machine$double.eps)))\n\t\tstop(\"Terms in the intra-subject model matrix are not orthogonal.\")\n}\n\nlinearHypothesis.mlm <- function(model, hypothesis.matrix, rhs=NULL, SSPE, V,\n\t\ttest, idata, icontrasts=c(\"contr.sum\", \"contr.poly\"), idesign, iterms,\n\t\tcheck.imatrix=TRUE, P=NULL, title=\"\", singular.ok=FALSE, verbose=FALSE, ...){\n\tif (missing(test)) test <- c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\")\n\ttest <- match.arg(test, c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\"),\n\t\t\tseveral.ok=TRUE)\n\tdf.residual <- df.residual(model)\n\twts <- if (!is.null(model$weights)) model$weights else rep(1,nrow(model.matrix(model)))\n\t# V = (X'WX)^{-1}\n\tif (missing (V)) V <- solve(wcrossprod(model.matrix(model), w=wts))\n\tB <- coef(model)\n\tif (is.character(hypothesis.matrix)) {\n\t\tL <- makeHypothesis(rownames(B), hypothesis.matrix, rhs)\n\t\tif (is.null(dim(L))) L <- t(L)\n\t\tL <- L[, -NCOL(L), drop = FALSE]\n\t\trownames(L) <- hypothesis.matrix\n\t}\n\telse {\n\t\tL <- if (is.null(dim(hypothesis.matrix))) t(hypothesis.matrix)\n\t\t\t\telse hypothesis.matrix\n\t}\n\t# SSPE = E'WE\n\tif (missing(SSPE)) SSPE <- wcrossprod(residuals(model),w=wts)\n\tif (missing(idata)) idata <- NULL\n\tif (missing(idesign)) idesign <- NULL\n\tif (!is.null(idata)){\n\t\tfor (i in 1:length(idata)){\n\t\t\tif (is.null(attr(idata[,i], \"contrasts\"))){\n\t\t\t\tcontrasts(idata[,i]) <- if (is.ordered(idata[,i])) icontrasts[2]\n\t\t\t\t\t\telse icontrasts[1]\n\t\t\t}\n\t\t}\n\t\tif (is.null(idesign)) stop(\"idesign (intra-subject design) missing.\")\n\t\tX.design <- model.matrix(idesign, data=idata)\n\t\tif (check.imatrix) check.imatrix(X.design)\n\t\tintercept <- has.intercept(X.design)\n\t\tterm.names <- term.names(idesign)\n\t\tif (intercept) term.names <- c(\"(Intercept)\", term.names)\n\t\twhich.terms <- match(iterms, term.names)\n\t\tif (any(nas <- is.na(which.terms))){\n\t\t\tif (sum(nas) == 1)\n\t\t\t\tstop('The term \"', iterms[nas],'\" is not in the intrasubject design.')\n\t\t\telse stop(\"The following terms are not in the intrasubject design: \",\n\t\t\t\t\t\tpaste(iterms[nas], collapse=\", \"), \".\")\n\t\t}\n\t\tselect <- apply(outer(which.terms, attr(X.design, \"assign\") + intercept, \"==\"),\n\t\t\t\t2, any)\n\t\tP <- X.design[, select, drop=FALSE]\n\t}\n\tif (!is.null(P)){\n\t\trownames(P) <- colnames(B)\n\t\tSSPE <- t(P) %*% SSPE %*% P\n\t\tB <- B %*% P\n\t}\n\trank <- sum(eigen(SSPE, only.values=TRUE)$values >= sqrt(.Machine$double.eps))\n\tif (!singular.ok && rank < ncol(SSPE))\n\t\tstop(\"The error SSP matrix is apparently of deficient rank = \",\n\t\t\t\trank, \" < \", ncol(SSPE))\n\tr <- ncol(B)\n\tif (is.null(rhs)) rhs <- matrix(0, nrow(L), r)\n\trownames(rhs) <- rownames(L)\n\tcolnames(rhs) <- colnames(B)\n\tq <- NROW(L)\n\tif (verbose){\n\t\tcat(\"\\nHypothesis matrix:\\n\")\n\t\tprint(L)\n\t\tcat(\"\\nRight-hand-side matrix:\\n\")\n\t\tprint(rhs)\n\t\tcat(\"\\nEstimated linear function (hypothesis.matrix %*% coef - rhs):\\n\")\n\t\tprint(drop(L %*% B - rhs))\n\t\tcat(\"\\n\")\n\t}\n\tSSPH <- t(L %*% B - rhs) %*% solve(L %*% V %*% t(L)) %*% (L %*% B - rhs)\n\trval <- list(SSPH=SSPH, SSPE=SSPE, df=q, r=r, df.residual=df.residual, P=P,\n\t\t\ttitle=title, test=test, singular=rank < ncol(SSPE))\n\tclass(rval) <- \"linearHypothesis.mlm\"\n\trval\n}\n\n#linearHypothesis.mlm <- function(model, hypothesis.matrix, rhs=NULL, SSPE, V,\n#   test, idata, icontrasts=c(\"contr.sum\", \"contr.poly\"), idesign, iterms,\n#   check.imatrix=TRUE, P=NULL, title=\"\", verbose=FALSE, ...){\n#   if (missing(test)) test <- c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\")\n#   test <- match.arg(test, c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\"),\n#       several.ok=TRUE)\n#   df.residual <- df.residual(model)\n#   if (missing (V)) V <- solve(crossprod(model.matrix(model)))\n#   B <- coef(model)\n#   if (is.character(hypothesis.matrix)) {\n#       L <- makeHypothesis(rownames(B), hypothesis.matrix, rhs)\n#       if (is.null(dim(L))) L <- t(L)\n#       L <- L[, -NCOL(L), drop = FALSE]\n#       rownames(L) <- hypothesis.matrix\n#   }\n#   else {\n#       L <- if (is.null(dim(hypothesis.matrix))) t(hypothesis.matrix)\n#           else hypothesis.matrix\n#   }\n#   if (missing(SSPE)) SSPE <- crossprod(residuals(model))\n#   if (missing(idata)) idata <- NULL\n#   if (missing(idesign)) idesign <- NULL\n#   if (!is.null(idata)){\n#       for (i in 1:length(idata)){\n#           if (is.null(attr(idata[,i], \"contrasts\"))){\n#               contrasts(idata[,i]) <- if (is.ordered(idata[,i])) icontrasts[2]\n#                   else icontrasts[1]\n#           }\n#       }\n#       if (is.null(idesign)) stop(\"idesign (intra-subject design) missing.\")\n#       X.design <- model.matrix(idesign, data=idata)\n#       if (check.imatrix) check.imatrix(X.design)\n#       intercept <- has.intercept(X.design)\n#       term.names <- term.names(idesign)\n#       if (intercept) term.names <- c(\"(Intercept)\", term.names)\n#       which.terms <- match(iterms, term.names)\n#       if (any(nas <- is.na(which.terms))){\n#           if (sum(nas) == 1)\n#               stop('The term \"', iterms[nas],'\" is not in the intrasubject design.')\n#           else stop(\"The following terms are not in the intrasubject design: \",\n#                   paste(iterms[nas], collapse=\", \"), \".\")\n#       }\n#       select <- apply(outer(which.terms, attr(X.design, \"assign\") + intercept, \"==\"),\n#           2, any)\n#       P <- X.design[, select, drop=FALSE]\n#   }\n#   if (!is.null(P)){\n#       rownames(P) <- colnames(B)\n#       SSPE <- t(P) %*% SSPE %*% P\n#       B <- B %*% P\n#   }\n#   rank <- sum(eigen(SSPE, only.values=TRUE)$values >= sqrt(.Machine$double.eps))\n#   if (rank < ncol(SSPE))\n#       stop(\"The error SSP matrix is apparently of deficient rank = \",\n#           rank, \" < \", ncol(SSPE))\n#   r <- ncol(B)\n#   if (is.null(rhs)) rhs <- matrix(0, nrow(L), r)\n#   rownames(rhs) <- rownames(L)\n#   colnames(rhs) <- colnames(B)\n#   q <- NROW(L)\n#   if (verbose){\n#       cat(\"\\nHypothesis matrix:\\n\")\n#       print(L)\n#       cat(\"\\nRight-hand-side matrix:\\n\")\n#       print(rhs)\n#       cat(\"\\nEstimated linear function (hypothesis.matrix %*% coef - rhs):\\n\")\n#       print(drop(L %*% B - rhs))\n#       cat(\"\\n\")\n#   }\n#   SSPH <- t(L %*% B - rhs) %*% solve(L %*% V %*% t(L)) %*% (L %*% B - rhs)\n#   rval <- list(SSPH=SSPH, SSPE=SSPE, df=q, r=r, df.residual=df.residual, P=P,\n#       title=title, test=test)\n#   class(rval) <- \"linearHypothesis.mlm\"\n#   rval\n#}\n\nprint.linearHypothesis.mlm <- function(x, SSP=TRUE, SSPE=SSP,\n\t\tdigits=getOption(\"digits\"), ...){\n\ttest <- x$test\n\tif (!is.null(x$P) && SSP){\n\t\tP <- x$P\n\t\tcat(\"\\n Response transformation matrix:\\n\")\n\t\tattr(P, \"assign\") <- NULL\n\t\tattr(P, \"contrasts\") <- NULL\n\t\tprint(P, digits=digits)\n\t}\n\tif (SSP){\n\t\tcat(\"\\nSum of squares and products for the hypothesis:\\n\")\n\t\tprint(x$SSPH, digits=digits)\n\t}\n\tif (SSPE){\n\t\tcat(\"\\nSum of squares and products for error:\\n\")\n\t\tprint(x$SSPE, digits=digits)\n\t}\n\tif ((!is.null(x$singular)) && x$singular){\n\t\twarning(\"the error SSP matrix is singular; multivariate tests are unavailable\")\n\t\treturn(invisible(x))\n\t}\n\tSSPE.qr <- qr(x$SSPE)\n\t# the following code is adapted from summary.manova\n\teigs <- Re(eigen(qr.coef(SSPE.qr, x$SSPH), symmetric = FALSE)$values)\n\ttests <- matrix(NA, 4, 4)\n\trownames(tests) <- c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\")\n\tif (\"Pillai\" %in% test)\n\t\ttests[1, 1:4] <- Pillai(eigs, x$df, x$df.residual)\n\tif (\"Wilks\" %in% test)\n\t\ttests[2, 1:4] <- Wilks(eigs, x$df, x$df.residual)\n\tif (\"Hotelling-Lawley\" %in% test)\n\t\ttests[3, 1:4] <- HL(eigs, x$df, x$df.residual)\n\tif (\"Roy\" %in% test)\n\t\ttests[4, 1:4] <- Roy(eigs, x$df, x$df.residual)\n\ttests <- na.omit(tests)\n\tok <- tests[, 2] >= 0 & tests[, 3] > 0 & tests[, 4] > 0\n\tok <- !is.na(ok) & ok\n\ttests <- cbind(x$df, tests, pf(tests[ok, 2], tests[ok, 3], tests[ok, 4],\n\t\t\t\t\tlower.tail = FALSE))\n\tcolnames(tests) <- c(\"Df\", \"test stat\", \"approx F\", \"num Df\", \"den Df\", \"Pr(>F)\")\n\ttests <- structure(as.data.frame(tests),\n\t\t\theading = paste(\"\\nMultivariate Test\",\n\t\t\t\t\tif (nrow(tests) > 1) \"s\", \": \", x$title, sep=\"\"),\n\t\t\tclass = c(\"anova\", \"data.frame\"))\n\tprint(tests, digits=digits)\n\tinvisible(x)\n}\n\nlinearHypothesis.survreg <- function(model, hypothesis.matrix, rhs=NULL,\n\t\ttest=c(\"Chisq\", \"F\"), vcov., verbose=FALSE, ...){\n\tif (missing(vcov.)) {\n\t\tvcov. <- vcov(model)\n\t\tp <- which(rownames(vcov.) == \"Log(scale)\")\n\t\tif (length(p) > 0) vcov. <- vcov.[-p, -p]\n\t}\n\tlinearHypothesis.default(model, hypothesis.matrix, rhs, test, vcov., verbose=verbose, ...)\n}\n\nlinearHypothesis.polr <- function (model, hypothesis.matrix, rhs=NULL, vcov., verbose=FALSE, ...){\n\tk <- length(coef(model))\n\tV <- vcov(model)[1:k, 1:k]\n\tlinearHypothesis.default(model, hypothesis.matrix, rhs, vcov.=V, verbose=verbose, ...)\n}\n\ncoef.multinom <- function(object, ...){\n    # the following local function is copied from nnet:::coef.multinom\n    coef.m <- function (object, ...) {\n            r <- length(object$vcoefnames)\n            if (length(object$lev) == 2L) {\n                coef <- object$wts[1L + (1L:r)]\n                names(coef) <- object$vcoefnames\n            }\n            else {\n                coef <- matrix(object$wts, nrow = object$n[3L], byrow = TRUE)[, \n                                                                              1L + (1L:r), drop = FALSE]\n                if (length(object$lev)) \n                    dimnames(coef) <- list(object$lev, object$vcoefnames)\n                if (length(object$lab)) \n                    dimnames(coef) <- list(object$lab, object$vcoefnames)\n                coef <- coef[-1L, , drop = FALSE]\n            }\n            coef\n        }\n    \n\tb <- coef.m(object, ...)\n\tcn <- colnames(b)\n\trn <- rownames(b)\n\tb <- as.vector(t(b))\n\tnames(b) <- as.vector(outer(cn, rn, function(c, r) paste(r, c, sep=\":\")))\n\tb\n}\n\n## functions for mixed models\n\nlinearHypothesis.merMod <- function(model, hypothesis.matrix, rhs=NULL,\n                                 vcov.=NULL, test=c(\"Chisq\", \"F\"), \n                                 singular.ok=FALSE, verbose=FALSE, ...){\n    linearHypothesis.mer(model=model, hypothesis.matrix=hypothesis.matrix,\n                         vcov.=vcov., test=test, singular.ok=singular.ok,\n                         verbose=verbose, ...)\n}\n\nlinearHypothesis.mer <- function(model, hypothesis.matrix, rhs=NULL,\n                                 vcov.=NULL, test=c(\"Chisq\", \"F\"), singular.ok=FALSE, verbose=FALSE, ...){\n    test <- match.arg(test)\n    V <- as.matrix(if (is.null(vcov.))vcov(model)\n                   else if (is.function(vcov.)) vcov.(model) else vcov.)\n    b <- fixef(model)\n    if (any(aliased <- is.na(b)) && !singular.ok)\n        stop(\"there are aliased coefficients in the model\")\n    b <- b[!aliased]\n    if (is.character(hypothesis.matrix)) {\n        L <- makeHypothesis(names(b), hypothesis.matrix, rhs)\n        if (is.null(dim(L))) L <- t(L)\n        rhs <- L[, NCOL(L)]\n        L <- L[, -NCOL(L), drop = FALSE]\n        rownames(L) <- hypothesis.matrix\n    }\n    else {\n        L <- if (is.null(dim(hypothesis.matrix))) t(hypothesis.matrix)\n        else hypothesis.matrix\n        if (is.null(rhs)) rhs <- rep(0, nrow(L))\n    }\n    q <- NROW(L)\n    if (verbose){\n        cat(\"\\nHypothesis matrix:\\n\")\n        print(L)\n        cat(\"\\nRight-hand-side vector:\\n\")\n        print(rhs)\n        cat(\"\\nEstimated linear function (hypothesis.matrix %*% coef - rhs)\\n\")\n        print(drop(L %*% b - rhs))\n        cat(\"\\n\")\n    }\n    if (test == \"Chisq\"){\n        df <- Inf\n        SSH <- as.vector(t(L %*% b - rhs) %*% solve(L %*% V %*% t(L)) %*% (L %*% b - rhs))\n    }\n    else {\n        if (!requireNamespace(\"lme4\")) stop(\"lme4 package is missing\")\n#        if (!require(\"pbkrtest\") || packageVersion(\"pbkrtest\") < \"0.3.2\") stop(\"pbkrtest package version >= 0.3.2 required for F-test on linear mixed model\")\n        if (!lme4::isREML(model)) \n            stop(\"F test available only for linear mixed model fit by REML\")\n#        res <- pbkrtest::KRmodcomp(model, L)$test\n        res <- KRmodcomp(model, L)$test\n        df <- res[\"Ftest\", \"ddf\"]\n        F <- res[\"Ftest\", \"stat\"]\n        p <- res[\"Ftest\", \"p.value\"]\n    }\n    name <- try(formula(model), silent = TRUE)\n    if (inherits(name, \"try-error\")) name <- substitute(model)\n    title <- \"Linear hypothesis test\\n\\nHypothesis:\"\n    topnote <- paste(\"Model 1: restricted model\",\"\\n\", \"Model 2: \", \n                     paste(deparse(name), collapse = \"\\n\"), sep = \"\")\n    note <- if (is.null(vcov.)) \"\"\n    else \"\\nNote: Coefficient covariance matrix supplied.\\n\"\n    rval <- matrix(rep(NA, 8), ncol = 4)\n    if (test == \"Chisq\"){\n        colnames(rval) <- c(\"Res.Df\", \"Df\", \"Chisq\",  paste(\"Pr(>Chisq)\", sep = \"\"))\n        rownames(rval) <- 1:2\n        rval[,1] <- c(df+q, df)\n        p <- pchisq(SSH, q, lower.tail = FALSE)\n        rval[2, 2:4] <- c(q, SSH, p)\n        rval <- rval[,-1]\n    }\n    else{\n        colnames(rval) <- c(\"Res.Df\", \"Df\", \"F\",  paste(\"Pr(>F)\", sep = \"\"))\n        rownames(rval) <- 1:2\n        rval[,1] <- c(df+q, df)\n        rval[2, 2:4] <- c(q, F, p)\n    }\n    structure(as.data.frame(rval),\n              heading = c(title, printHypothesis(L, rhs, names(b)), \"\", topnote, note),\n              class = c(\"anova\", \"data.frame\"))\n}\n\nlinearHypothesis.lme <- function(model, hypothesis.matrix, rhs=NULL,\n\t\tvcov.=NULL, singular.ok=FALSE, verbose=FALSE, ...){\n\tV <- as.matrix(if (is.null(vcov.))vcov(model)\n\t\t\t\t\telse if (is.function(vcov.)) vcov.(model) else vcov.)\n\tb <- fixef(model)\n\tif (any(aliased <- is.na(b)) && !singular.ok)\n\t\tstop(\"there are aliased coefficients in the model\")\n\tb <- b[!aliased]\n\tif (is.character(hypothesis.matrix)) {\n\t\tL <- makeHypothesis(names(b), hypothesis.matrix, rhs)\n\t\tif (is.null(dim(L))) L <- t(L)\n\t\trhs <- L[, NCOL(L)]\n\t\tL <- L[, -NCOL(L), drop = FALSE]\n\t\trownames(L) <- hypothesis.matrix\n\t}\n\telse {\n\t\tL <- if (is.null(dim(hypothesis.matrix))) t(hypothesis.matrix)\n\t\t\t\telse hypothesis.matrix\n\t\tif (is.null(rhs)) rhs <- rep(0, nrow(L))\n\t}\n\tq <- NROW(L)\n\tif (verbose){\n\t\tcat(\"\\nHypothesis matrix:\\n\")\n\t\tprint(L)\n\t\tcat(\"\\nRight-hand-side vector:\\n\")\n\t\tprint(rhs)\n\t\tcat(\"\\nEstimated linear function (hypothesis.matrix %*% coef - rhs)\\n\")\n\t\tprint(drop(L %*% b - rhs))\n\t\tcat(\"\\n\")\n\t}\n\tdf <- Inf\n\tSSH <- as.vector(t(L %*% b - rhs) %*% solve(L %*% V %*% t(L)) %*% (L %*% b - rhs))\n\tname <- try(formula(model), silent = TRUE)\n\tif (inherits(name, \"try-error\")) name <- substitute(model)\n\ttitle <- \"Linear hypothesis test\\n\\nHypothesis:\"\n\ttopnote <- paste(\"Model 1: restricted model\",\"\\n\", \"Model 2: \", \n\t\t\tpaste(deparse(name), collapse = \"\\n\"), sep = \"\")\n\tnote <- if (is.null(vcov.)) \"\"\n\t\t\telse \"\\nNote: Coefficient covariance matrix supplied.\\n\"\n\trval <- matrix(rep(NA, 8), ncol = 4)\n\tcolnames(rval) <- c(\"Res.Df\", \"Df\", \"Chisq\",  paste(\"Pr(>Chisq)\", sep = \"\"))\n\trownames(rval) <- 1:2\n\trval[,1] <- c(df+q, df)\n\tp <- pchisq(SSH, q, lower.tail = FALSE)\n\trval[2, 2:4] <- c(q, SSH, p)\n\trval <- rval[,-1]\n\tstructure(as.data.frame(rval),\n\t\t\theading = c(title, printHypothesis(L, rhs, names(b)), \"\", topnote, note),\n\t\t\tclass = c(\"anova\", \"data.frame\"))\n}\n\n## for svyglm\n\nlinearHypothesis.svyglm <- function(model, ...) linearHypothesis.default(model, ...)\n\n## for rlm\n\ndf.residual.rlm <- function(object, ...){\n  p <- length(coef(object))\n  wt.method <- object$call$wt.method\n  if (!is.null(wt.method) && wt.method == \"case\") {\n    sum(object$weights) - p\n  }\n  else length(object$wresid) - p\n}\n\nlinearHypothesis.rlm <- function(model, ...) linearHypothesis.default(model, test=\"F\", ...)\n\n\n## matchCoefs\n\nmatchCoefs <- function(model, pattern, ...) UseMethod(\"matchCoefs\")\n\nmatchCoefs.default <- function(model, pattern, coef.=coef, ...){\n\tnames <- names(coef.(model))\n\tgrep(pattern, names, value=TRUE)\n}\n\nmatchCoefs.mer <- function(model, pattern, ...) NextMethod(coef.=fixef)\n\nmatchCoefs.merMod <- function(model, pattern, ...) NextMethod(coef.=fixef)\n\nmatchCoefs.lme <- function(model, pattern, ...) NextMethod(coef.=fixef)\n\nmatchCoefs.mlm <- function(model, pattern, ...){\n\tnames <- rownames(coef(model))\n\tgrep(pattern, names, value=TRUE)\n}\n\n\n",
    "created" : 1487209921061.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2859466635",
    "id" : "8B6269C4",
    "lastKnownWriteTime" : 1486662499,
    "last_content_update" : 1486662499,
    "path" : "~/Documents/GitHub/car3/R/linearHypothesis.R",
    "project_path" : "R/linearHypothesis.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}